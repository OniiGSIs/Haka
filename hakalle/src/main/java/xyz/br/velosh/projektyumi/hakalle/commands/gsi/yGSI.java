/*
    Project YuMi
    Copyright (C) 2022 Hakalle

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package xyz.br.velosh.projektyumi.hakalle.commands.gsi;

import com.annimon.tgbotsmodule.api.methods.answerqueries.AnswerCallbackQueryMethod;
import com.annimon.tgbotsmodule.api.methods.send.SendMessageMethod;
import com.annimon.tgbotsmodule.api.methods.updatingmessages.DeleteMessageMethod;
import com.annimon.tgbotsmodule.api.methods.updatingmessages.EditMessageTextMethod;
import com.annimon.tgbotsmodule.commands.CommandBundle;
import com.annimon.tgbotsmodule.commands.CommandRegistry;
import com.annimon.tgbotsmodule.commands.SimpleCallbackQueryCommand;
import com.annimon.tgbotsmodule.commands.SimpleCommand;
import com.annimon.tgbotsmodule.commands.authority.For;
import com.annimon.tgbotsmodule.commands.context.CallbackQueryContext;
import com.annimon.tgbotsmodule.commands.context.MessageContext;
import net.schmizz.sshj.SSHClient;
import net.schmizz.sshj.sftp.SFTPClient;
import net.schmizz.sshj.transport.verification.PromiscuousVerifier;
import org.apache.commons.io.FilenameUtils;
import org.apache.commons.lang3.RandomStringUtils;
import org.jetbrains.annotations.NotNull;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.telegram.telegrambots.meta.api.objects.replykeyboard.InlineKeyboardMarkup;
import org.telegram.telegrambots.meta.api.objects.replykeyboard.buttons.InlineKeyboardButton;
import xyz.br.velosh.projektyumi.hakalle.bot.gsi.GSICmdObj;
import xyz.br.velosh.projektyumi.hakalle.utils.gsi.FileUtils;
import xyz.br.velosh.projektyumi.hakalle.utils.gsi.ModelUtils;
import xyz.br.velosh.projektyumi.hakalle.utils.gsi.ToolUtils;
import xyz.br.velosh.projektyumi.hakalle.utils.gsi.exception.ReadmeException;
import xyz.br.velosh.projektyumi.hakalle.utils.gsi.exception.ReadmeNoSuchFileException;

import java.io.*;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.*;
import java.util.concurrent.atomic.AtomicReference;
import java.util.stream.Stream;

import static xyz.br.velosh.projektyumi.hakalle.Main.readOutputFile;
import static xyz.br.velosh.projektyumi.hakalle.bot.Hakalle.botConfig;
import static xyz.br.velosh.projektyumi.hakalle.Main.statusGSI;

/**
 * @author Hakalle <xdhakalle@gmail.com>
 * This is where the system images generated by the tool will come out.
 */
public class yGSI implements CommandBundle<For> {
    /**
     * Logger: To send warning, info & errors to terminal.
     */
    private static final Logger logger = LoggerFactory.getLogger(yGSI.class);

    /**
     * Main variables to GSI process.
     */
    private static final ArrayList<GSICmdObj> gsiCmdObj = new ArrayList<>();

    /**
     * Dummy variables.
     */
    String pVarUrl, pVarGSI, pVarArgs, pVarNotice;

    // Enable SpellCheckingInspection since url2sgsi isn't a typo.
    @SuppressWarnings("SpellCheckingInspection")
    @Override
    public void register(@NotNull CommandRegistry<For> registry) {
        registry.register(new SimpleCallbackQueryCommand("kill", callbackQueryContext -> {
            // User which who asked to deny user's order.
            final String builderGSIUser = String.valueOf(callbackQueryContext.user().getId());

            // Check if the denyOrderUser is the creator.
            if (!builderGSIUser.equals(botConfig.getCreatorId().toString())) {
                callbackQueryContext.answerAsAlert("You're not authorized to do this action.")
                        .callAsync(callbackQueryContext.sender);
                return;
            }

            // Kill the GSI.
            ProcessBuilder processBuilder;
            processBuilder = new ProcessBuilder("/bin/bash", "-c", "kill -TERM -- -$(ps ax | grep url2GSI.sh | grep -v grep | awk '{print $1;}'); kill -TERM -- -$(ps ax | grep make.sh | grep -v grep | awk '{print $1;}'); kill -TERM -- -$(ps ax | grep zip2img.sh | grep -v grep | awk '{print $1;}'); kill -TERM -- -$(ps ax | grep merger.sh | grep -v grep | awk '{print $1;}')");
            try {
                processBuilder.start();
                processBuilder.redirectErrorStream(true);
            } catch (IOException ignored) {
                callbackQueryContext.answerAsAlert("Failed to kill the process!")
                        .callAsync(callbackQueryContext.sender);
                return;
            }

            // Delete the GSI process message.
            DeleteMessageMethod deleteMessageMethod = new DeleteMessageMethod();
            deleteMessageMethod.setChatId(callbackQueryContext.message().getChatId());
            deleteMessageMethod.setMessageId(callbackQueryContext.message().getMessageId());
            deleteMessageMethod.callAsync(callbackQueryContext.sender);

            // Answer the queryId.
            AnswerCallbackQueryMethod answerCallbackQueryMethod = new AnswerCallbackQueryMethod();
            answerCallbackQueryMethod
                    .setCallbackQueryId(callbackQueryContext.queryId())
                    .callAsync(callbackQueryContext.sender);
        }));
        registry.register(new SimpleCallbackQueryCommand("run", callbackQueryContext -> {
            // User which who asked to deny user's order.
            final String builderGSIUser = String.valueOf(callbackQueryContext.user().getId());

            // Check if the denyOrderUser is the creator.
            if (!builderGSIUser.equals(botConfig.getCreatorId().toString())) {
                callbackQueryContext.answerAsAlert("You're not authorized to do this action.")
                        .callAsync(callbackQueryContext.sender);
                return;
            }

            // Set up the GSI configs.
            GSICmdObj gsiCommand = validateData(callbackQueryContext);

            // Check if has been returned fine.
            if (gsiCommand == null) {
                SendMessageMethod sendMessageMethod = new SendMessageMethod();
                sendMessageMethod.setChatId(callbackQueryContext.message().getChatId());
                sendMessageMethod.setText("Failure to define the arguments for the GSI process! Please check if there is something wrong in the command.")
                        .callAsync(callbackQueryContext.sender);
                return;
            }

            // Check if the GSI process is blocked.
            if (!statusGSI.getIsWaiting()) {
                statusGSI.mSetWait(true);
                secondStage(callbackQueryContext, gsiCommand);
                while (gsiCmdObj.size() != 0) {
                    GSICmdObj gsiNow = gsiCmdObj.get(0);
                    gsiCmdObj.remove(0);
                    secondStage(callbackQueryContext, gsiNow);
                }
                statusGSI.mSetWait(false);
            } else {
                // Delete the confirmation message.
                DeleteMessageMethod deleteMessageMethod = new DeleteMessageMethod();
                deleteMessageMethod.setChatId(callbackQueryContext.message().getChatId());
                deleteMessageMethod.setMessageId(callbackQueryContext.message().getMessageId());
                deleteMessageMethod.callAsync(callbackQueryContext.sender);

                // Add the GSI to the queue.
                gsiCmdObj.add(gsiCommand);

                // Alert the builder.
                SendMessageMethod sendMessageMethod = new SendMessageMethod();
                sendMessageMethod.setChatId(callbackQueryContext.message().getChatId());
                sendMessageMethod.setText("Added to queue.")
                        .callAsync(callbackQueryContext.sender);
            }

            // Answer the queryId.
            AnswerCallbackQueryMethod answerCallbackQueryMethod = new AnswerCallbackQueryMethod();
            answerCallbackQueryMethod
                    .setCallbackQueryId(callbackQueryContext.queryId())
                    .callAsync(callbackQueryContext.sender);
        }));
        registry.register(new SimpleCallbackQueryCommand("cancel", callbackQueryContext -> {
            // User which who asked to deny user's order.
            final String cancelGSIUser = String.valueOf(callbackQueryContext.user().getId());

            // Check if the denyOrderUser is the creator.
            if (!cancelGSIUser.equals(botConfig.getCreatorId().toString())) {
                callbackQueryContext.answerAsAlert("You're not authorized to do this action.")
                        .callAsync(callbackQueryContext.sender);
                return;
            }

            // Delete the GSI message.
            DeleteMessageMethod deleteMessageMethod = new DeleteMessageMethod();
            deleteMessageMethod.setChatId(callbackQueryContext.message().getChatId());
            deleteMessageMethod.setMessageId(callbackQueryContext.message().getMessageId());
            deleteMessageMethod.callAsync(callbackQueryContext.sender);

            // Need to say anything?
            SendMessageMethod sendMessageMethod = new SendMessageMethod();
            sendMessageMethod.setChatId(callbackQueryContext.message().getChatId());
            sendMessageMethod.setText("The GSI process command has been canceled.")
                    .callAsync(callbackQueryContext.sender);

            // Answer the queryId.
            AnswerCallbackQueryMethod answerCallbackQueryMethod = new AnswerCallbackQueryMethod();
            answerCallbackQueryMethod
                    .setCallbackQueryId(callbackQueryContext.queryId())
                    .callAsync(callbackQueryContext.sender);
        }));
        registry.register(new SimpleCommand("/url2gsi", this::initialStage));
        registry.register(new SimpleCommand("/url2sgsi", this::initialStage));
        registry.register(new SimpleCommand("/loligsi", this::initialStage));
    }

    // Enable SpellCheckingInspection since url2sgsi isn't a typo.
    @SuppressWarnings("SpellCheckingInspection")
    private void initialStage(MessageContext messageContext) {
        // User which who asked to accept user's order.
        final String runner = String.valueOf(messageContext.user().getId());

        // Check if the denyOrderUser is the creator.
        if (!runner.equals(botConfig.getCreatorId().toString())) {
            messageContext.replyToMessage("You're not authorized to do this action.")
                    .callAsync(messageContext.sender);
            return;
        }

        // Setup firstly our arguments.
        String[] msgComparableRaw = messageContext.message().getText().split(" ");

        // Try to get arguments.
        String fwURL;
        String fwName;
        String fwArgs;
        String fwNotice;
        try {
            fwURL = msgComparableRaw[1];
            fwName = msgComparableRaw[2];
        } catch (Exception exception) {
            messageContext.replyToMessage("Bad or incorrect usage.")
                    .callAsync(messageContext.sender);
            return;
        }

        // Check if still the problem.
        if (fwURL == null
            || fwName == null) {
            messageContext.replyToMessage("Bad or incorrect usage.")
                    .callAsync(messageContext.sender);
            return;
        }

        // Check if the fwName has special name.
        var romBase = "";
        var romSpecialName = "";
        var romNameHTML = "";
        if (fwName.contains(":")) {
            romBase = fwName.split(":")[0];
            romSpecialName = fwName.split(":")[1].replace("-", " ");
            romNameHTML = "" + romSpecialName + " (<code>" + romBase + "</code>)";
        } else {
            romNameHTML = fwName;
        }

        // Try to get fwArgs.
        StringBuilder argStrBuilder = new StringBuilder();
        for (int arg = 3; arg < msgComparableRaw.length; arg++) {
            if (!msgComparableRaw[arg].startsWith("-")) continue;
            argStrBuilder.append(msgComparableRaw[arg]).append(" ");
        }
        fwArgs = argStrBuilder.toString();
        try {
            fwArgs = fwArgs.substring(0, fwArgs.length() - 1);
        } catch (Exception ignored) {}

        StringBuilder argsTextStrBuilder = new StringBuilder();
        var argsTextStr = "";
        if (fwArgs.contains("-a")) argsTextStrBuilder.append("Build A-only only | ");
        if (fwArgs.contains("-b")) argsTextStrBuilder.append("Build AB only | ");
        if (fwArgs.contains("-c")) argsTextStrBuilder.append("Clean after extract | ");
        if (fwArgs.contains("-m")) argsTextStrBuilder.append("Use dynamic script");
        if (argsTextStrBuilder.toString().isBlank()
            || argsTextStrBuilder.toString().isEmpty()) {
            argsTextStr = "No argument was required or requested.";
        } else {
            argsTextStr = argsTextStrBuilder.toString();
        }
        if (argsTextStr.endsWith("| ")) argsTextStr = argsTextStr.substring(0, argsTextStr.length() - 3);

        // Try to get fwNotice;
        StringBuilder noticeStrBuilder = new StringBuilder();
        for (int arg = 3; arg < msgComparableRaw.length; arg++) {
            if (msgComparableRaw[arg].startsWith("-")) continue;
            noticeStrBuilder.append(msgComparableRaw[arg]).append(" ");
        }
        fwNotice = noticeStrBuilder.toString();
        try {
            fwNotice = fwNotice.substring(0, fwNotice.length() - 1);
        } catch (Exception ignored) {}
        if (fwNotice.isEmpty()
            || fwNotice.isBlank()) {
            fwNotice = "No information was shared by the user who made this port.";
        }

        // Setup InlineKeyboardButton variable.
        final var keyboard = new ArrayList<List<InlineKeyboardButton>>(1);

        // Create our inline buttons.
        var inlineKeyboardButtonStart = InlineKeyboardButton.builder()
                .text("✅ Start")
                .callbackData("run")
                .build();
        var inlineKeyboardButtonCancel = InlineKeyboardButton.builder()
                .text("❌ Cancel")
                .callbackData("cancel:" + messageContext.message().getFrom().getId() + ":" + messageContext.message().getFrom().getFirstName())
                .build();

        // Finish our inline buttons setup.
        keyboard.add(List.of(inlineKeyboardButtonStart));
        keyboard.add(List.of(inlineKeyboardButtonCancel));

        // Send the message with inline buttons.
        SendMessageMethod sendMessageMethod = new SendMessageMethod();
        sendMessageMethod.setText(
                "\uD83D\uDCE8 | <b>Firmware's Name</b> — " + romNameHTML + "\n" +
                "\uD83D\uDCCC | <b>Firmware's Filename or URL</b> — <code>" + fwURL + "</code>\n" +
                "❕ | <b>Additional info</b> — <code>" + fwNotice + "</code>\n\n" +
                "⌨️ | <b>Arguments which were requested</b> — <code>" + argsTextStr + "</code>"
        );
        sendMessageMethod.setChatId(messageContext.chatId());
        sendMessageMethod.setReplyMarkup(InlineKeyboardMarkup.builder().keyboard(keyboard).build());
        sendMessageMethod.enableHtml(true);
        sendMessageMethod.callAsync(messageContext.sender);

        // Set the GSI vars.
        pVarUrl = fwURL;
        pVarArgs = fwArgs;
        pVarGSI = fwName;
        pVarNotice = fwNotice;
    }

    // Enable SpellCheckingInspection since Hakalle isn't a typo.
    @SuppressWarnings("SpellCheckingInspection")
    private void secondStage(CallbackQueryContext callbackQueryContext, GSICmdObj gsiCmdObj) {
        // Define our main variables.
        boolean goodResult = false;
        ProcessBuilder processBuilder;
        InputStream inputStream = null;
        InputStreamReader inputStreamReader = null;
        BufferedReader bufferedReader = null;
        StringBuilder stringBuilder = new StringBuilder();
        stringBuilder.append("<code>-> [Loli] Preparing...</code>");

        // Delete the inline query message.
        DeleteMessageMethod deleteMessageMethod = new DeleteMessageMethod();
        deleteMessageMethod.setMessageId(callbackQueryContext.message().getMessageId());
        deleteMessageMethod.setChatId(callbackQueryContext.message().getChatId());
        deleteMessageMethod.callAsync(callbackQueryContext.sender);

        // Setup InlineKeyboardButton variable.
        final var keyboard = new ArrayList<List<InlineKeyboardButton>>(1);
        var inlineKeyboardButtonCancel = InlineKeyboardButton.builder()
                .text("❌ Cancel the process")
                .callbackData("kill")
                .build();

        // Finish our inline buttons setup.
        keyboard.add(List.of(inlineKeyboardButtonCancel));

        // Create our new message for GSI process/logging.
        SendMessageMethod sendMessageMethod = new SendMessageMethod();
        sendMessageMethod.setChatId(callbackQueryContext.message().getChatId());
        sendMessageMethod.setText(stringBuilder.toString());
        sendMessageMethod.enableHtml(true);
        int messageIdGSI = sendMessageMethod.call(callbackQueryContext.sender).getMessageId();

        // Create our editable message.
        EditMessageTextMethod editMessageTextMethod = new EditMessageTextMethod();
        editMessageTextMethod.setChatId(callbackQueryContext.message().getChatId());
        editMessageTextMethod.setMessageId(messageIdGSI);
        editMessageTextMethod.setText(stringBuilder.toString());
        editMessageTextMethod.enableHtml(true);

        // Here we go.
        processBuilder = new ProcessBuilder("/bin/bash", "-c",
                "cd " + ToolUtils.mPath + " ; ./url2GSI.sh '" + gsiCmdObj.getUrl() + "' " + gsiCmdObj.getGsi() + " " + gsiCmdObj.getArgs()
        );
        stringBuilder.append("\n<code> | Done! Here we go.</code>");
        editMessageTextMethod.setText(stringBuilder.toString())
                .callAsync(callbackQueryContext.sender);

        try {
            // Define Shell core variables.
            processBuilder.redirectErrorStream(true);
            Process process = processBuilder.start();
            inputStream = process.getInputStream();
            inputStreamReader = new InputStreamReader(inputStream);
            bufferedReader = new BufferedReader(inputStreamReader);

            // Temporary variable for adding lines.
            String line;

            // Here we go again².
            while ((line = bufferedReader.readLine()) != null) {
                if (line.isEmpty()
                    || line.isBlank()) continue;

                line = "<code>" + line + "</code>";
                stringBuilder.append("\n").append(line);
                editMessageTextMethod.setText(stringBuilder.toString())
                        .callAsync(callbackQueryContext.sender);

                // Check whether the system partition is mounted, and
                // if it is mounted: Make the GSI operation cancelable.
                if (ToolUtils.isSystemMounted())
                    editMessageTextMethod.setReplyMarkup(InlineKeyboardMarkup.builder().keyboard(keyboard).build())
                            .callAsync(callbackQueryContext.sender);
            }

            process.waitFor();
            if (process.exitValue() == 0)
                goodResult = true;
        } catch (IOException | InterruptedException ignored) {} finally {
            if (inputStream != null) {
                try {
                    inputStream.close();
                } catch (IOException ignored) {}
            }

            if (inputStreamReader != null) {
                try {
                    inputStreamReader.close();
                } catch (IOException ignored) {}
            }

            if (bufferedReader != null) {
                try {
                    bufferedReader.close();
                } catch (IOException ignored) {}
            }
        }

        if (goodResult) {
            // When done, we create an EditMessageTextMethod without reply markup, since isn't cancellable anymore.
            EditMessageTextMethod editMessageTextMethodWithoutMarkup = new EditMessageTextMethod();
            editMessageTextMethodWithoutMarkup.setChatId(callbackQueryContext.message().getChatId());
            editMessageTextMethodWithoutMarkup.setMessageId(messageIdGSI);
            editMessageTextMethodWithoutMarkup.setText(String.valueOf(stringBuilder));
            editMessageTextMethodWithoutMarkup.enableHtml(true);
            editMessageTextMethodWithoutMarkup.callAsync(callbackQueryContext.sender);

            // Activate the ReadmeOutputFile & ModelUtils tasks.
            try {
                // Set its path.
                readOutputFile.setReadmePath(ToolUtils.mPath + "/output/README.md");

                // Read the README.md.
                // Also, that is necessary for ModelUtils.
                readOutputFile.read();

                // Check if the codename uses anything special tbh.
                ModelUtils modelUtils = new ModelUtils(readOutputFile);
                modelUtils.fix();
            } catch (ReadmeNoSuchFileException | ReadmeException e) {
                logger.info(e.getMessage(), e);
            }

            // Now we need to compress all these images.
            String[] gzipFiles = listFilesForFolder(new File(ToolUtils.mPath + "/output"));
            for (String gzipFile : gzipFiles) {
                stringBuilder.append("\n").append("<code>-> Gzipping: ").append(gzipFile).append(".gz").append("</code>");
                editMessageTextMethodWithoutMarkup.setText(String.valueOf(stringBuilder))
                        .callAsync(callbackQueryContext.sender);
                new FileUtils().gzipFile(gzipFile, gzipFile + ".gz");
            }

            // Set up our variables to set A-only, AB, Vendor & ODM Overlays filenames.
            ArrayList<String> arrayGsiStuffList = new ArrayList<>();
            AtomicReference<String> aonlyFilename = new AtomicReference<>("");
            AtomicReference<String> abFilename = new AtomicReference<>("");
            AtomicReference<String> vendorOverlaysFilename = new AtomicReference<>("");
            AtomicReference<String> odmOverlaysFilename = new AtomicReference<>("");

            try (Stream<Path> paths = Files.walk(Paths.get(ToolUtils.mPath + "/output"))) {
                paths
                        .filter(Files::isRegularFile)
                        .forEach(fileName -> {
                            // Add all files presents on output folder.
                            arrayGsiStuffList.add(fileName.toString());
                            if (fileName.toString().endsWith(".gz")) {
                                // Define our atomic variables.
                                if (fileName.toString().contains("Aonly")) {
                                    aonlyFilename.set(FilenameUtils.getBaseName(fileName.toString())
                                            + "."
                                            + FilenameUtils.getExtension(fileName.toString()
                                    ));
                                } else if (fileName.toString().contains("AB")) {
                                    abFilename.set(FilenameUtils.getBaseName(fileName.toString())
                                            + "."
                                            + FilenameUtils.getExtension(fileName.toString()
                                    ));
                                } else if (fileName.toString().contains("VendorOverlays")) {
                                    vendorOverlaysFilename.set(FilenameUtils.getBaseName(fileName.toString())
                                            + "."
                                            + FilenameUtils.getExtension(fileName.toString()
                                    ));
                                } else if (fileName.toString().contains("ODMOverlays")) {
                                    odmOverlaysFilename.set(FilenameUtils.getBaseName(fileName.toString())
                                            + "."
                                            + FilenameUtils.getExtension(fileName.toString()
                                    ));
                                }
                            }
                        });
            } catch (IOException ioException) {
                logger.error(ioException.getMessage());
            }

            // Upload the built GSI stuff into SourceForge.
            stringBuilder.append("\n").append("<code>-> [Loli] Uploading to SourceForge...</code>");
            editMessageTextMethodWithoutMarkup.setText(String.valueOf(stringBuilder))
                    .callAsync(callbackQueryContext.sender);

            String gsiName = gsiCmdObj.getGsi();
            String mPath = null;
            try {
                // First of all, define our gsiName var.
                String mModel = readOutputFile.getCodename() == null ? "Unknown" : readOutputFile.getCodename();
                if (gsiName.contains(":")) {
                    gsiName = gsiName.split(":")[0];
                }

                // Brute hash our random chars.
                String randomString = RandomStringUtils.randomAlphanumeric(1);
                String firstSalt = generateSalt(1);
                String secondSalt = generateSalt(1);
                String thirdSalt = generateSalt(1);
                String hashRandom = getSecureHash(randomString, firstSalt + secondSalt + thirdSalt);

                // Set up our JSch and its configs.
                SSHClient sshClient = new SSHClient();
                sshClient.addHostKeyVerifier(new PromiscuousVerifier());
                sshClient.connect("frs.sourceforge.net");
                sshClient.authPassword(botConfig.getSourceForgeUsername(), botConfig.getSourceForgePassword());
                SFTPClient sftpClient = sshClient.newSFTPClient();

                // Set up both vars for path.
                gsiName = gsiName + "/" + hashRandom + "/" + mModel;
                mPath = "/home/frs/project/" + botConfig.getSourceForgeProject() + "/" +
                        gsiName;

                // Create the path to upload the files.
                sftpClient.mkdirs(mPath);

                // Upload all files.
                for (String filename : arrayGsiStuffList) {
                    if (!filename.endsWith(".img")) {
                        sftpClient.put(filename, mPath);
                    }
                }
            } catch (Exception exception) {
                logger.error(exception.getMessage());
            }

            // Now drop the SF path. We'll use that variable to set on url.
            mPath = Objects.requireNonNull(mPath).replace("/home/frs/project/" + botConfig.getSourceForgeProject() + "/", "");

            // Update it.
            stringBuilder.append("\n").append("<code> | Done!</code>");
            editMessageTextMethodWithoutMarkup.setText(String.valueOf(stringBuilder))
                    .callAsync(callbackQueryContext.sender);

            // Set up our Keyboard Markup.
            InlineKeyboardMarkup inlineKeyboardMarkup = new InlineKeyboardMarkup();

            // Set up our Keyboard Button list for listing.
            List<List<InlineKeyboardButton>> buttonsList = new ArrayList<>();

            // Set up our Keyboard Button list.
            List<InlineKeyboardButton> partitionTypeDownload = new ArrayList<>();
            List<InlineKeyboardButton> overlayTypeDownload = new ArrayList<>();

            // Create AB button.
            if (!abFilename.toString().trim().equals("")) {
                InlineKeyboardButton abButton = new InlineKeyboardButton();
                abButton.setText("AB Download");
                abButton.setUrl("https://sourceforge.net/projects/" + botConfig.getSourceForgeProject() + "/files/" + mPath + "/" + abFilename);
                partitionTypeDownload.add(abButton);
            }

            // Create A-only button.
            if (!aonlyFilename.toString().trim().equals("")) {
                InlineKeyboardButton aonlyButton = new InlineKeyboardButton();
                aonlyButton.setText("A-only Download");
                aonlyButton.setUrl("https://sourceforge.net/projects/" + botConfig.getSourceForgeProject() + "/files/" + mPath + "/" + aonlyFilename);
                partitionTypeDownload.add(aonlyButton);
            }

            // Create Vendor Overlay button.
            if (!vendorOverlaysFilename.toString().trim().equals("")) {
                InlineKeyboardButton vendorOverlayButton = new InlineKeyboardButton();
                vendorOverlayButton.setText("Vendor Overlay Download");
                vendorOverlayButton.setUrl("https://sourceforge.net/projects/" + botConfig.getSourceForgeProject() + "/files/" + mPath + "/" + vendorOverlaysFilename);
                overlayTypeDownload.add(vendorOverlayButton);
            }

            // Create ODM Overlay button.
            if (!odmOverlaysFilename.toString().trim().equals("")) {
                InlineKeyboardButton odmOverlayButton = new InlineKeyboardButton();
                odmOverlayButton.setText("ODM Overlay Download");
                odmOverlayButton.setUrl("https://sourceforge.net/projects/" + botConfig.getSourceForgeProject() + "/files/" + mPath + "/" + odmOverlaysFilename);
                overlayTypeDownload.add(odmOverlayButton);
            }

            // Add the only list of rows inline buttons into markup.
            buttonsList.add(partitionTypeDownload);
            buttonsList.add(overlayTypeDownload);

            // Define our only list of rows inline buttons to the keyboard markup.
            inlineKeyboardMarkup.setKeyboard(buttonsList);

            // Try to get model's name & output.
            var mModelName = "";
            var mOutput = "";
            try {
                pVarNotice = pVarNotice == null
                        ? "No information was shared by the user who made this port."
                        : pVarNotice;
                mModelName = readOutputFile.getModelName() == null
                        ? "Unknown"
                        : readOutputFile.getModelName();
                mOutput = readOutputFile.getOutput() == null
                        ? "Failed to get output, edit this message with the correct information if you've."
                        : readOutputFile.getOutput();
            } catch (ReadmeException ignored) {}

            // Set GSI name.
            gsiName = gsiCmdObj.getGsi();
            if (gsiName.contains(":")) {
                if (gsiName.split(":")[1].contains("-")) {
                    gsiName = gsiName.split(":")[1].replace("-", " ") + " (" + gsiName.split(":")[0] + ")";
                } else {
                    gsiName = gsiName.split(":")[1] + " (" + gsiName.split(":")[0] + ")";
                }
            }

            // Create our SendMessageMethod and send it.
            SendMessageMethod sendMessageMethodPost = new SendMessageMethod();
            sendMessageMethodPost.setChatId(botConfig.getChannelId());
            sendMessageMethodPost.enableHtml(true);
            sendMessageMethodPost.setText("<b>Ported</b> " + gsiName + " <b>| GSI</b>" + "\n" +
                    "<b>From </b>" + mModelName + "\n" +
                    "<b>Built by</b> <a href=\"" + "tg://user?id=" + gsiCmdObj.getBuilderId() + "\">" + gsiCmdObj.getBuilderName() + "</a>" + "\n\n" +
                    "<b>Information</b>" + "\n" +
                    "<code>" + mOutput + "</code>" + "\n\n" +
                    "<b>Technical Info</b>" + "\n" +
                    gsiCmdObj.getNotice() + "\n\n" +
                    "<b>Credits</b>" + "\n" +
                    "<a href=\"https://github.com/Erfanoabdi\">Erfan Abdi</a>" + " | " +
                    "<a href=\"https://github.com/xiaoxindada\">Xiaoxindada</a>" + " | " +
                    "<a href=\"https://github.com/phhusson\">Husson</a>\n\n"
            );
            sendMessageMethodPost.setReplyMarkup(inlineKeyboardMarkup);
            int postMessageId = sendMessageMethodPost.call(callbackQueryContext.sender).getMessageId();

            // Set up our Keyboard Markup.
            InlineKeyboardMarkup inlineKeyboardMarkupPost = new InlineKeyboardMarkup();

            // Set up our Keyboard Button list for listing.
            List<List<InlineKeyboardButton>> buttonListPost = new ArrayList<>();

            // Set up our Keyboard Button list.
            List<InlineKeyboardButton> buttonList = new ArrayList<>();

            // Create our post button.
            InlineKeyboardButton postButton = new InlineKeyboardButton();
            postButton.setText("\uD83D\uDCCC Post link");
            postButton.setUrl("https://t.me/" + botConfig.getChannel() + "/" + postMessageId);
            buttonList.add(postButton);

            // Add the only list of rows inline buttons into markup.
            buttonListPost.add(buttonList);

            // Define our only list of rows inline buttons to the keyboard markup.
            inlineKeyboardMarkupPost.setKeyboard(buttonListPost);

            // Update our GSI process message.
            editMessageTextMethodWithoutMarkup.setReplyMarkup(inlineKeyboardMarkupPost)
                    .callAsync(callbackQueryContext.sender);

            // Clear all variables.
            gsiCmdObj.clean();
            arrayGsiStuffList.clear();
            aonlyFilename.set(null);
            vendorOverlaysFilename.set(null);
            odmOverlaysFilename.set(null);
            abFilename.set(null);
        } else {
            // Make it uncancellable.
            EditMessageTextMethod editMessageTextMethodWithoutMarkup = new EditMessageTextMethod();
            editMessageTextMethodWithoutMarkup.setChatId(callbackQueryContext.message().getChatId());
            editMessageTextMethodWithoutMarkup.setMessageId(messageIdGSI);
            editMessageTextMethodWithoutMarkup.setText(String.valueOf(stringBuilder));
            editMessageTextMethodWithoutMarkup.enableHtml(true)
                    .callAsync(callbackQueryContext.sender);

            // Create our new message for GSI process/logging.
            SendMessageMethod sendMessageMethodFail = new SendMessageMethod();
            sendMessageMethodFail.setChatId(callbackQueryContext.message().getChatId());
            sendMessageMethodFail.setReplyToMessageId(messageIdGSI);
            sendMessageMethodFail.setText("Beep bop... Something wrong isn't correct, the GSI process failed, check if something is wrong.")
                    .callAsync(callbackQueryContext.sender);

            // Clear all variables.
            gsiCmdObj.clean();
        }

        // Also clean.
        pVarGSI = "";
        pVarArgs = "";
        pVarUrl = "";
        pVarNotice = "";
    }

    private GSICmdObj validateData(CallbackQueryContext callbackQueryContext) {
        if (callbackQueryContext == null) return null;

        // Try to define our variables.
        GSICmdObj gsiCmdObj = new GSICmdObj();

        // Set our scripts args.
        String mUrl = pVarUrl;
        String mFwName = pVarGSI;
        String mArgs = pVarArgs;
        String mNotice = pVarNotice;

        // Define the args.
        gsiCmdObj.setGsi(mFwName);
        gsiCmdObj.setUrl(mUrl);
        gsiCmdObj.setParam(mArgs);
        gsiCmdObj.setNotice(mNotice);
        gsiCmdObj.setBuilderName(callbackQueryContext.user().getFirstName());
        gsiCmdObj.setBuilderId(callbackQueryContext.user().getId().toString());
        return gsiCmdObj;
    }

    private static String[] listFilesForFolder(final File folder) {
        StringBuilder paths = new StringBuilder();
        for (final File fileEntry : Objects.requireNonNull(folder.listFiles())) {
            if (fileEntry.isDirectory()) {
                listFilesForFolder(fileEntry);
            } else {
                if (fileEntry.getName().contains(".img")) {
                    paths.append(fileEntry.getAbsolutePath()).append("\n");
                }
            }
        }
        return paths.toString().split("\n");
    }

    @SuppressWarnings("all")
    private static String generateSalt(int length) {
        String abcCapitals = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
        String abcLowerCase = "abcdefghijklmnopqrstuvwxyz";
        String numbers = "01234567890123456789";
        String characters = "!@#$%^&*!@#$%%^^&*";
        String total = abcCapitals + abcLowerCase + numbers + characters;
        String response = "";

        char[] letters = new char[length];
        for (int i = 0; i < length - 1; i++) {
            Random random = new Random();
            char letter = total.charAt(random.nextInt(total.length()));
            letters[i] = letter;
        }

        response = Arrays.toString(letters).replaceAll("\\s+","");
        response = response.replaceAll(",","");
        return response;
    }

    private static String getHash(String passwordToHash, String salt) {
        String generatedPassword = null;
        try {
            MessageDigest messageDigest = MessageDigest.getInstance("SHA-512");
            messageDigest.update(salt.getBytes(StandardCharsets.UTF_8));

            byte[] bytes = messageDigest.digest(passwordToHash.getBytes(StandardCharsets.UTF_8));

            StringBuilder sb = new StringBuilder();

            for (byte aByte : bytes) {
                sb.append(Integer.toString((aByte & 0xff) + 0x100, 16).substring(1));
            }

            generatedPassword = sb.toString();
        }
        catch (NoSuchAlgorithmException ignored) {}
        return generatedPassword;
    }

    public static String getSecureHash(String password, String salt) {
        String hash = getHash(password, salt);
        for (int i = 0; i < 55; i++) hash = getHash(password, hash);
        return hash;
    }
}
